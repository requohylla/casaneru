

![](/images/architecture/bff.jpg)

# 目次
- [目次](#目次)
- [BFFとは](#bffとは)
- [登場経緯](#登場経緯)
- [メリット](#メリット)
  - [フロントとバックエンドの差異を吸収することができる](#フロントとバックエンドの差異を吸収することができる)
  - [認証、権限、キャッシュの分離](#認証権限キャッシュの分離)
  - [APIの集約](#apiの集約)
- [デメリット](#デメリット)
  - [コードの冗長化](#コードの冗長化)
  - [通信の増加](#通信の増加)
- [フロント + BFF + バックエンド(gRPG)参考記事](#フロント--bff--バックエンドgrpg参考記事)


# BFFとは
「取得データがそのまま表示用データになればいいのに」という想いをかなえるのがBFFです。

BFFを採用するとクライアントはBFFとのみAPI通信を行います。BFFでデータ整形まで行った状態でクライアントに返答することで、クライアントでは取得したデータをそのまま表示することが可能になります。また複数のバックエンドに問い合わせる際も、クライアントはBFFにのみアクセスをするのでURLも通信のデータ規範も1つで良くなります。

名前にもある通り、フロントエンドのためのバックエンドですのでフロントエンドエンジニアが担当する方が合理的です。

「マイクロサービス化における課題を解決するためにできたアーキテクチャ」という側面もある

# 登場経緯
クライアント端末の増加したことに伴うロジックの増加です。
例えばweb、スマホ版web、スマホアプリ、デスクトップアプリなど複数のクライアント登場により、それぞれにコンテンツのだし分けを実装する必要があり、冗長なコードを書かざるを得ない。

そこで、複数のバックエンドから情報を取得し、適切な形に整形するロジックを持つサーバが導入された。それがBFFの登場経緯


# メリット

- フロントエンドとバックエンドの業務分離の明確化
- レスポンスをフロント用に成形することでの処理の簡略化
- バックエンド要因による依存が減るので開発体験が向上（バックエンドの差異吸収）
- キャッシュの一元化

## フロントとバックエンドの差異を吸収することができる
差異については、フロント定義が「name」のストリングがバックエンド定義では「displayName」であることは多くあります。これをBFFで紐づけることでフロント定義に丸め込むことができます。また、BFFでダミーデータを作っておけばフロントは開発に注力することができます。

## 認証、権限、キャッシュの分離
BFFに認証、権限、キャッシュなどの処理を実装すれば、フロントとバックはそれらを気にしなくてよい

## APIの集約
マイクロサービスアーキテクチャなど複数のバックエンドへリクエストをする際Proxyとしての役割を持たすことができるので、　クライアントからのエンドポイントは一つに集約することができます。


# デメリット
- 開発・運用コストが増加する（通信量の増加や遅延の可能性もあり）
- BFFが止まればすべてが止まる
- BFFのデプロイが必要
- コードの冗長化（APIだけでもよくない？という瞬間）

## コードの冗長化
フロント定義とバック定義の差異があまりない場合などでは、コード上で処理を挟み込む必要がないので冗長なコードを作成することになります。

## 通信の増加
モノリシックよりも遥かに通信量が増えるので、データ取得までの時間がかかる。帯域の増強などが必要


# フロント + BFF + バックエンド(gRPG)参考記事
よくある構成
フロントエンド → Next.js
BFF → Nest.js
バックエンド → Go + gRPC

なぜgRPC
結論：BFFとバックエンド間の通信速度が遅くならない様にする為

フロントとBFFの通信はGraphQL
BFFとバックエンド(マイクロサービスで作られた)間はgRPC

https://zenn.dev/highgrenade/scraps/e8d1b065d3a4fa